var global, factory;
global = this,
  factory = function (e) {
    const t = (e, t) => t.skipCache || "GET" !== t.method,
      o = (e, t) => t.method + "@" + e,
      n = (e, t) => 0,
      a = (e, t) => null,
      r = (e) => e.ok;
    e.throttlingCache = (
      {
        throttle: e = 1e3,
        skip: c = t,
        key: l = o,
        clear: i = n,
        invalidate: s = a,
        condition: f = r,
        flagResponseOnCacheHit: h = "__cached",
      } = {},
    ) => {
      const d = new Map(),
        g = new Map(),
        p = new Set(),
        u = (t) => {
          e && !p.has(t) && (p.add(t),
            setTimeout(() => {
              p.delete(t);
            }, e));
        },
        y = (e) => (t, o) => {
          const n = l(t, o);
          let a = s(t, o);
          if (
            a && (a instanceof Array || (a = [a]),
              a.forEach((e) => {
                "string" == typeof e
                  ? d.delete(e)
                  : e instanceof RegExp && d.forEach((t, o) => {
                    e.test(o) && d.delete(o);
                  });
              })),
              i(t, o) && d.clear(),
              c(t, o)
          ) return e(t, o);
          if (p.has(n)) {
            if (d.has(n)) {
              const e = d.get(n).clone();
              return h &&
                Object.defineProperty(e, h, { value: n, enumerable: 0 }),
                Promise.resolve(e);
            }
            if (g.has(n)) {
              return new Promise((e, t) => {
                g.get(n).push([e, t]);
              });
            }
          }
          return g.has(n) || g.set(n, []),
            u(n),
            e(t, o).then(
              (
                e,
              ) => (f(e.clone()) && d.set(n, e.clone()),
                g.get(n).forEach(([t]) => t(e.clone())),
                g.delete(n),
                e),
            ).catch((e) => {
              throw g.get(n).forEach(([t, o]) => o(e)), g.delete(n), e;
            });
        };
      return y.cacheResponse = function (e, t) {
        u(e), d.set(e, t);
      },
        y.cache = d,
        y.inflight = g,
        y.throttling = p,
        y;
    };
  },
  "object" == typeof exports && "undefined" != typeof module
    ? factory(exports)
    : "function" == typeof define && define.amd
    ? define(["exports"], factory)
    : factory(
      (global = "undefined" != typeof globalThis ? globalThis : global || self)
        .wretchThrottlingCacheMiddleware = {},
    );
//# sourceMappingURL=throttlingCache.min.js.map
