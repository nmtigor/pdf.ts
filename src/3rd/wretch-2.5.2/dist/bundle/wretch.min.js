!function (e, t) {
  "object" == typeof exports && "undefined" != typeof module
    ? module.exports = t()
    : "function" == typeof define && define.amd
    ? define(t)
    : (e = "undefined" != typeof globalThis ? globalThis : e || self).wretch =
      t();
}(this, function () {
  "use strict";
  const e = "Content-Type", t = Symbol();
  function r(t = {}) {
    var r;
    return null ===
          (r = Object.entries(t).find(([t]) =>
            t.toLowerCase() === e.toLowerCase()
          )) || void 0 === r
      ? void 0
      : r[1];
  }
  function o(e) {
    return /^application\/.*json.*/.test(e);
  }
  const s = function (e, t, r = 0) {
      return Object.entries(t).reduce((t, [o, n]) => {
        const i = e[o];
        return Array.isArray(i) && Array.isArray(n)
          ? t[o] = r ? [...i, ...n] : n
          : t[o] = "object" == typeof i && "object" == typeof n
            ? s(i, n, r)
            : n,
          t;
      }, { ...e });
    },
    n = {
      options: {},
      errorType: "text",
      polyfills: {},
      polyfill(e, t = 1, r = 0, ...o) {
        const s = this.polyfills[e] ||
          ("undefined" != typeof self ? self[e] : null) ||
          ("undefined" != typeof global ? global[e] : null);
        if (t && !s) throw new Error(e + " is not defined");
        return r && s ? new s(...o) : s;
      },
    };
  class i extends Error {}
  const h = (e) => {
      const r = Object.create(null);
      e = e._addons.reduce(
        (t, o) => o.beforeRequest && o.beforeRequest(t, e._options, r) || t,
        e,
      );
      const {
          _url: o,
          _options: n,
          _config: h,
          _catchers: u,
          _resolvers: l,
          _middlewares: c,
          _addons: a,
        } = e,
        d = new Map(u),
        f = s(h.options, n);
      let p = o;
      const _ = ((e) => (t) => e.reduceRight((e, t) => t(e), t) || t)(c)(
          (e, t) => (p = e, h.polyfill("fetch")(e, t)),
        )(o, f),
        y = new Error(),
        w = _.catch((e) => {
          throw { __wrap: e };
        }).then((e) => {
          if (!e.ok) {
            const t = new i();
            if (
              t.cause = y,
                t.stack = t.stack + "\nCAUSE: " + y.stack,
                t.response = e,
                t.url = p,
                "opaque" === e.type
            ) throw t;
            return e.text().then((r) => {
              var o;
              if (
                t.message = r,
                  "json" === h.errorType ||
                  "application/json" ===
                    (null === (o = e.headers.get("Content-Type")) ||
                        void 0 === o
                      ? void 0
                      : o.split(";")[0])
              ) {
                try {
                  t.json = JSON.parse(r);
                } catch (e) {}
              }
              throw t.text = r, t.status = e.status, t;
            });
          }
          return e;
        }),
        b = (r) => (o) =>
          (r
            ? w.then((e) => e && e[r]()).then((e) => o ? o(e) : e)
            : w.then((e) => o ? o(e) : e)).catch((r) => {
              const o = r.__wrap || r,
                s = o.status && d.get(o.status) || d.get(o.name) ||
                  r.__wrap && d.has(t) && d.get(t);
              if (s) return s(o, e);
              throw o;
            }),
        g = {
          _wretchReq: e,
          _fetchReq: _,
          _sharedState: r,
          res: b(null),
          json: b("json"),
          blob: b("blob"),
          formData: b("formData"),
          arrayBuffer: b("arrayBuffer"),
          text: b("text"),
          error(e, t) {
            return d.set(e, t), this;
          },
          badRequest(e) {
            return this.error(400, e);
          },
          unauthorized(e) {
            return this.error(401, e);
          },
          forbidden(e) {
            return this.error(403, e);
          },
          notFound(e) {
            return this.error(404, e);
          },
          timeout(e) {
            return this.error(408, e);
          },
          internalError(e) {
            return this.error(500, e);
          },
          fetchError(e) {
            return this.error(t, e);
          },
        },
        j = a.reduce((e, t) => ({ ...e, ...t.resolver }), g);
      return l.reduce((t, r) => r(t, e), j);
    },
    u = {
      _url: "",
      _options: {},
      _config: n,
      _catchers: new Map(),
      _resolvers: [],
      _deferred: [],
      _middlewares: [],
      _addons: [],
      addon(e) {
        return { ...this, _addons: [...this._addons, e], ...e.wretch };
      },
      errorType(e) {
        return { ...this, _config: { ...this._config, errorType: e } };
      },
      polyfills(e, t = 0) {
        return {
          ...this,
          _config: {
            ...this._config,
            polyfills: t ? e : s(this._config.polyfills, e),
          },
        };
      },
      url(e, t = 0) {
        if (t) return { ...this, _url: e };
        const r = this._url.split("?");
        return {
          ...this,
          _url: r.length > 1 ? r[0] + e + "?" + r[1] : this._url + e,
        };
      },
      options(e, t = 0) {
        return { ...this, _options: t ? e : s(this._options, e) };
      },
      headers(e) {
        return { ...this, _options: s(this._options, { headers: e || {} }) };
      },
      accept(e) {
        return this.headers({ Accept: e });
      },
      content(t) {
        return this.headers({ [e]: t });
      },
      auth(e) {
        return this.headers({ Authorization: e });
      },
      catcher(e, t) {
        const r = new Map(this._catchers);
        return r.set(e, t), { ...this, _catchers: r };
      },
      resolve(e, t = 0) {
        return { ...this, _resolvers: t ? [e] : [...this._resolvers, e] };
      },
      defer(e, t = 0) {
        return { ...this, _deferred: t ? [e] : [...this._deferred, e] };
      },
      middlewares(e, t = 0) {
        return { ...this, _middlewares: t ? e : [...this._middlewares, ...e] };
      },
      fetch(e = this._options.method, t = "", s = null) {
        let n = this.url(t).options({ method: e });
        const i = r(n._options.headers),
          u = "object" == typeof s && (!n._options.headers || !i || o(i));
        return n = s ? u ? n.json(s, i) : n.body(s) : n,
          h(n._deferred.reduce((e, t) => t(e, e._url, e._options), n));
      },
      get(e = "") {
        return this.fetch("GET", e);
      },
      delete(e = "") {
        return this.fetch("DELETE", e);
      },
      put(e, t = "") {
        return this.fetch("PUT", t, e);
      },
      post(e, t = "") {
        return this.fetch("POST", t, e);
      },
      patch(e, t = "") {
        return this.fetch("PATCH", t, e);
      },
      head(e = "") {
        return this.fetch("HEAD", e);
      },
      opts(e = "") {
        return this.fetch("OPTIONS", e);
      },
      body(e) {
        return { ...this, _options: { ...this._options, body: e } };
      },
      json(e, t) {
        const s = r(this._options.headers);
        return this.content(t || o(s) && s || "application/json").body(
          JSON.stringify(e),
        );
      },
    };
  function l(e = "", t = {}) {
    return { ...u, _url: e, _options: t };
  }
  return l.default = l,
    l.options = function (e, t = 0) {
      n.options = t ? e : s(n.options, e);
    },
    l.errorType = function (e) {
      n.errorType = e;
    },
    l.polyfills = function (e, t = 0) {
      n.polyfills = t ? e : s(n.polyfills, e);
    },
    l.WretchError = i,
    l;
});
//# sourceMappingURL=wretch.min.js.map
