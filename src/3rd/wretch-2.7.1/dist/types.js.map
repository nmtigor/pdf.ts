{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * The Wretch object used to perform easy fetch requests.\n *\n * ```ts\n * import wretch from \"wretch\"\n *\n * // Reusable wretch instance\n * const w = wretch(\"https://domain.com\", { mode: \"cors\" })\n * ```\n *\n * Immutability : almost every method of this class return a fresh Wretch object.\n */\nexport interface Wretch<Self = unknown, Chain = unknown, Resolver = undefined> {\n  /**\n   * @private @internal\n   */\n  _url: string,\n  /**\n   * @private @internal\n   */\n  _options: WretchOptions,\n  /**\n   * @private @internal\n   */\n  _config: Config,\n  /**\n   * @private @internal\n   */\n  _catchers: Map<number | string | symbol, (error: WretchError, originalRequest: Wretch<Self, Chain, Resolver>) => void>\n  /**\n   * @private @internal\n   */\n  _resolvers: ((resolver: Resolver extends undefined ? Chain & WretchResponseChain<Self, Chain> : Resolver, originalRequest: Wretch<Self, Chain, Resolver>) => any)[]\n  /**\n   * @private @internal\n   */\n  _deferred: WretchDeferredCallback<Self, Chain, Resolver>[]\n  /**\n   * @private @internal\n   */\n  _middlewares: ConfiguredMiddleware[]\n  /**\n   * @private @internal\n   */\n  _addons: WretchAddon<unknown, Chain>[]\n\n  /**\n   * Register an Addon to enhance the wretch or response objects.\n   *\n   * ```js\n   * import FormDataAddon from \"wretch/addons/formData\"\n   * import QueryStringAddon from \"wretch/addons/queryString\"\n   *\n   * // Add both addons\n   * const w = wretch().addon(FormDataAddon).addon(QueryStringAddon)\n   *\n   * // Additional features are now available\n   * w.formData({ hello: \"world\" }).query({ check: true })\n   * ```\n   *\n   * @category Helpers\n   * @param addon - A Wretch addon to register\n   */\n  addon<W, R>(addon: WretchAddon<W, R>): W & Self & Wretch<Self & W, Chain & R, Resolver>\n\n  /**\n   * Sets the method (text, json ...) used to parse the data contained in the\n   * response body in case of an HTTP error is returned.\n   *\n   * _Note: if the response Content-Type header is set to \"application/json\", the body will be parsed as json regardless of the errorType._\n   *\n   * ```js\n   * wretch(\"http://server/which/returns/an/error/with/a/json/body\")\n   *   .errorType(\"json\")\n   *   .get()\n   *   .res()\n   *   .catch(error => {\n   *     // error[errorType] (here, json) contains the parsed body\n   *     console.log(error.json)\n   *   })\n   * ```\n   *\n   * @category Helpers\n   * @param method - The method to call on the Fetch response to read the body and use it as the Error message\n   */\n  errorType(this: Self & Wretch<Self, Chain, Resolver>, method: string): this\n\n  /**\n   * Sets non-global polyfills - for instance in browserless environments.\n   *\n   * Needed for libraries like [fetch-ponyfill](https://github.com/qubyte/fetch-ponyfill).\n   *\n   * ```javascript\n   * const fetch = require(\"node-fetch\");\n   * const FormData = require(\"form-data\");\n   *\n   * wretch(\"http://domain.com\")\n   *   .polyfills({\n   *     fetch: fetch,\n   *     FormData: FormData,\n   *     URLSearchParams: require(\"url\").URLSearchParams,\n   *   })\n   *   .get()\n   * ```\n   *\n   * @category Helpers\n   * @param polyfills - An object containing the polyfills\n   * @param replace - If true, replaces the current polyfills instead of mixing in\n   */\n  polyfills(this: Self & Wretch<Self, Chain, Resolver>, polyfills: Partial<Config[\"polyfills\"]>, replace?: boolean): this\n\n  /**\n   * Appends or replaces the url.\n   *\n   * ```js\n   * wretch(\"/root\").url(\"/sub\").get().json();\n   *\n   * // Can be used to set a base url\n   *\n   * // Subsequent requests made using the 'blogs' object will be prefixed with \"http://domain.com/api/blogs\"\n   * const blogs = wretch(\"http://domain.com/api/blogs\");\n   *\n   * // Perfect for CRUD apis\n   * const id = await blogs.post({ name: \"my blog\" }).json(blog => blog.id);\n   * const blog = await blogs.get(`/${id}`).json();\n   * console.log(blog.name);\n   *\n   * await blogs.url(`/${id}`).delete().res();\n   *\n   * // And to replace the base url if needed :\n   * const noMoreBlogs = blogs.url(\"http://domain2.com/\", true);\n   * ```\n   *\n   * @category Helpers\n   * @param url - Url segment\n   * @param replace - If true, replaces the current url instead of appending\n   */\n  url(this: Self & Wretch<Self, Chain, Resolver>, url: string, replace?: boolean): this\n\n  /**\n   * Sets the fetch options.\n   *\n   * ```js\n   * wretch(\"...\").options({ credentials: \"same-origin\" });\n   * ```\n   *\n   * Wretch being immutable, you can store the object for later use.\n   *\n   * ```js\n   * const corsWretch = wretch().options({ credentials: \"include\", mode: \"cors\" });\n   *\n   * corsWretch.get(\"http://endpoint1\");\n   * corsWretch.get(\"http://endpoint2\");\n   * ```\n   *\n   * You can override instead of mixing in the existing options by passing a boolean\n   * flag.\n   *\n   * ```js\n   * // By default options are mixed in :\n   * let w = wretch()\n   *   .options({ headers: { \"Accept\": \"application/json\" } })\n   *   .options({ encoding: \"same-origin\", headers: { \"X-Custom\": \"Header\" } });\n   * console.log(JSON.stringify(w._options))\n   * // => {\"encoding\":\"same-origin\", \"headers\":{\"Accept\":\"application/json\",\"X-Custom\":\"Header\"}}\n   *\n   * // With the flag, options are overridden :\n   * w = wretch()\n   *   .options({ headers: { \"Accept\": \"application/json\" } })\n   *   .options(\n   *     { encoding: \"same-origin\", headers: { \"X-Custom\": \"Header\" } },\n   *     true,\n   *   );\n   * console.log(JSON.stringify(w._options))\n   * // => {\"encoding\":\"same-origin\",\"headers\":{\"X-Custom\":\"Header\"}}\n   * ```\n   *\n   * @category Helpers\n   * @param options - New options\n   * @param replace - If true, replaces the existing options\n   */\n  options(this: Self & Wretch<Self, Chain, Resolver>, options: WretchOptions, replace?: boolean): this\n\n  /**\n   * Sets the request headers.\n   *\n   * ```js\n   * wretch(\"...\")\n   *   .headers({ \"Content-Type\": \"text/plain\", Accept: \"application/json\" })\n   *   .post(\"my text\")\n   *   .json();\n   * ```\n   *\n   * @category Helpers\n   * @param headerValues - An object containing header keys and values\n   */\n  headers(this: Self & Wretch<Self, Chain, Resolver>, headerValues: HeadersInit): this\n\n  /**\n   * Shortcut to set the \"Accept\" header.\n   *\n   * ```js\n   * wretch(\"...\").accept(\"application/json\");\n   * ```\n   *\n   * @category Helpers\n   * @param headerValue - Header value\n   */\n  accept(this: Self & Wretch<Self, Chain, Resolver>, headerValue: string): this\n\n  /**\n   * Shortcut to set the \"Content-Type\" header.\n   *\n   * ```js\n   * wretch(\"...\").content(\"application/json\");\n   * ```\n   *\n   * @category Helpers\n   * @param headerValue - Header value\n   */\n  content(this: Self & Wretch<Self, Chain, Resolver>, headerValue: string): this\n\n  /**\n   * Shortcut to set the \"Authorization\" header.\n   *\n   * ```js\n   * wretch(\"...\").auth(\"Basic d3JldGNoOnJvY2tz\");\n   * ```\n   *\n   * @category Helpers\n   * @param headerValue - Header value\n   */\n  auth(this: Self & Wretch<Self, Chain, Resolver>, headerValue: string): this\n\n  /**\n   * Adds a [catcher](https://github.com/elbywan/wretch#catchers) which will be\n   * called on every subsequent request error.\n   *\n   * Very useful when you need to perform a repetitive action on a specific error\n   * code.\n   *\n   * ```js\n   * const w = wretch()\n   *   .catcher(404, err => redirect(\"/routes/notfound\", err.message))\n   *   .catcher(500, err => flashMessage(\"internal.server.error\"))\n   *\n   * // No need to catch the 404 or 500 codes, they are already taken care of.\n   * w.get(\"http://myapi.com/get/something\").json()\n   *\n   * // Default catchers can be overridden if needed.\n   * w\n   * .get(\"http://myapi.com/get/something\")\n   * .notFound(err =>\n   *   // overrides the default 'redirect' catcher\n   *  )\n   * .json()\n   * ```\n   *\n   * The original request is passed along the error and can be used in order to\n   * perform an additional request.\n   *\n   * ```js\n   * const reAuthOn401 = wretch()\n   * .catcher(401, async (error, request) => {\n   *   // Renew credentials\n   *   const token = await wretch(\"/renewtoken\").get().text();\n   *   storeToken(token);\n   *   // Replay the original request with new credentials\n   *   return request.auth(token).fetch().unauthorized((err) => {\n   *     throw err;\n   *   }).json();\n   * });\n   *\n   * reAuthOn401\n   * .get(\"/resource\")\n   * .json() // <- Will only be called for the original promise\n   * .then(callback); // <- Will be called for the original OR the replayed promise result\n   * ```\n   *\n   * @category Helpers\n   * @param errorId - Error code or name\n   * @param catcher - The catcher method\n   */\n  catcher(this: Self & Wretch<Self, Chain, Resolver>, errorId: number | string | symbol, catcher: (error: WretchError, originalRequest: this) => any): this\n\n  /**\n   * A fallback catcher that will be called for any error thrown - if uncaught by other means.\n   *\n   * ```js\n   * wretch(url)\n   *   .catcher(404, err => redirect(\"/routes/notfound\", err.message))\n   *   .catcher(500, err => flashMessage(\"internal.server.error\"))\n   *   // this fallback will trigger for any error except the ones caught above (404 and 505)\n   *   .catcherFallback(err => {\n   *     log(\"Uncaught error:\", err)\n   *     throw err\n   *   })\n   * ```\n   *\n   * @category Helpers\n   * @see {@link Wretch.catcher} for more details.\n   * @param catcher - The catcher method\n   */\n  catcherFallback(this: Self & Wretch<Self, Chain, Resolver>, catcher: (error: WretchError, originalRequest: this) => any): this\n\n  /**\n   * Defer one or multiple request chain methods that will get called just before the request is sent.\n   *\n   * ```js\n   * // Small fictional example: deferred authentication\n   *\n   * // If you cannot retrieve the auth token while configuring the wretch object you can use .defer to postpone the call\n   * const api = wretch(\"http://some-domain.com\").defer((w, url, options) => {\n   *   // If we are hitting the route /user…\n   *   if (/\\/user/.test(url)) {\n   *     const { token } = options.context;\n   *     return w.auth(token);\n   *   }\n   *   return w;\n   * });\n   *\n   * // ... //\n   *\n   * const token = await getToken(request.session.user);\n   *\n   * // .auth gets called here automatically\n   * api.options({\n   *   context: { token },\n   * }).get(\"/user/1\").res();\n   * ```\n   *\n   * @category Helpers\n   * @param callback - Exposes the wretch instance, url and options to program deferred methods.\n   * @param clear - Replace the existing deferred methods if true instead of pushing to the existing list.\n   */\n  defer<Clear extends boolean = false>(\n    this: Self & Wretch<Self, Chain, Resolver>,\n    callback: WretchDeferredCallback<Self, Chain, Resolver>,\n    clear?: Clear\n  ): this\n\n  /**\n   * Programs a resolver to perform response chain tasks automatically.\n   *\n   * Very useful when you need to perform repetitive actions on the wretch response.\n   *\n   * _The clear argument, if set to true, removes previously defined resolvers._\n   *\n   * ```js\n   * // Program \"response\" chain actions early on\n   * const w = wretch()\n   *   .addon(PerfsAddon())\n   *   .resolve(resolver => resolver\n   *     // monitor every request…\n   *     .perfs(console.log)\n   *     // automatically parse and return json…\n   *     .json()\n   *   )\n   *\n   *  const myJson = await w.url(\"http://a.com\").get()\n   *  // Equivalent to:\n   *  // w.url(\"http://a.com\")\n   *  //  .get()\n   *  //  <- the resolver chain is automatically injected here !\n   *  //  .perfs(console.log)\n   *  //  .json()\n   *  ```\n   *\n   * @category Helpers\n   * @param resolver - Resolver callback\n   */\n  resolve<ResolverReturn, Clear extends boolean = false>(\n    this: Self & Wretch<Self, Chain, Resolver>,\n    resolver: (\n      chain:\n        Resolver extends undefined ?\n        Chain & WretchResponseChain<Self, Chain, undefined> :\n        Clear extends true ?\n        Chain & WretchResponseChain<Self, Chain, undefined> :\n        Resolver,\n      originalRequest: Self & Wretch<Self, Chain, Clear extends true ? undefined : Resolver>\n    ) => ResolverReturn,\n    clear?: Clear\n  ): Self & Wretch<Self, Chain, ResolverReturn>\n\n  /**\n   * Add middlewares to intercept a request before being sent.\n   *\n   * ```javascript\n   * // A simple delay middleware.\n   * const delayMiddleware = delay => next => (url, opts) => {\n   *   return new Promise(res => setTimeout(() => res(next(url, opts)), delay))\n   * }\n   *\n   * // The request will be delayed by 1 second.\n   * wretch(\"...\").middlewares([\n   *   delayMiddleware(1000)\n   * ]).get().res()\n   * ```\n   *\n   * @category Helpers\n   */\n  middlewares(this: Self & Wretch<Self, Chain, Resolver>, middlewares: ConfiguredMiddleware[], clear?: boolean): this\n\n  /**\n   * Sets the request body with any content.\n   *\n   * ```js\n   * wretch(\"...\").body(\"hello\").put();\n   * // Note that calling put/post methods with a non-object argument is equivalent:\n   * wretch(\"...\").put(\"hello\");\n   * ```\n   *\n   * @category Body Types\n   * @param contents - The body contents\n   */\n  body(this: Self & Wretch<Self, Chain, Resolver>, contents: any): this\n\n  /**\n   * Sets the \"Content-Type\" header, stringifies an object and sets the request body.\n   *\n   * ```js\n   * const jsonObject = { a: 1, b: 2, c: 3 };\n   * wretch(\"...\").json(jsonObject).post();\n   * // Note that calling an 'http verb' method with an object argument is equivalent:\n   * wretch(\"...\").post(jsonObject);\n   * ```\n   *\n   * @category Body Types\n   * @param jsObject - An object which will be serialized into a JSON\n   * @param contentType - A custom content type.\n   */\n  json(this: Self & Wretch<Self, Chain, Resolver>, jsObject: object, contentType?: string): this\n\n\n  /**\n   * Sends the request using the accumulated fetch options.\n   *\n   * Can be used to replay requests.\n   *\n   * ```js\n   * const reAuthOn401 = wretch()\n   * .catcher(401, async (error, request) => {\n   *   // Renew credentials\n   *   const token = await wretch(\"/renewtoken\").get().text();\n   *   storeToken(token);\n   *   // Replay the original request with new credentials\n   *   return request.auth(token).fetch().unauthorized((err) => {\n   *     throw err;\n   *   }).json();\n   * });\n   *\n   * reAuthOn401\n   * .get(\"/resource\")\n   * .json() // <- Will only be called for the original promise\n   * .then(callback); // <- Will be called for the original OR the replayed promise result\n   * ```\n   *\n   * @category HTTP\n   * @param method - The HTTP method to use\n   * @param url - Some url to append\n   * @param body - Set the body. Behaviour varies depending on the argument type, an object is considered as json.\n   */\n  fetch(this: Self & Wretch<Self, Chain, Resolver>, method?: string, url?: string, body?: any):\n    Resolver extends undefined ?\n    Chain & WretchResponseChain<Self, Chain, Resolver> :\n    Resolver\n  /**\n   * Performs a [GET](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET) request.\n   *\n   * ```js\n   * wretch(\"...\").get();\n   * ```\n   *\n   * @category HTTP\n   */\n  get(this: Self & Wretch<Self, Chain, Resolver>, url?: string):\n    Resolver extends undefined ?\n    Chain & WretchResponseChain<Self, Chain, Resolver> :\n    Resolver\n  /**\n   * Performs a [DELETE](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE) request.\n   *\n   * ```js\n   * wretch(\"...\").delete();\n   * ```\n   *\n   * @category HTTP\n   */\n  delete(this: Self & Wretch<Self, Chain, Resolver>, url?: string):\n    Resolver extends undefined ?\n    Chain & WretchResponseChain<Self, Chain, Resolver> :\n    Resolver\n  /**\n   * Performs a [PUT](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT) request.\n   *\n   * ```js\n   * wretch(\"...\").json({...}).put()\n   * ```\n   *\n   * @category HTTP\n   */\n  put(this: Self & Wretch<Self, Chain, Resolver>, body?: any, url?: string):\n    Resolver extends undefined ?\n    Chain & WretchResponseChain<Self, Chain, Resolver> :\n    Resolver\n  /**\n   * Performs a [POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST) request.\n   *\n   * ```js\n   * wretch(\"...\").json({...}).post()\n   * ```\n   *\n   * @category HTTP\n   */\n  post(this: Self & Wretch<Self, Chain, Resolver>, body?: any, url?: string):\n    Resolver extends undefined ?\n    Chain & WretchResponseChain<Self, Chain, Resolver> :\n    Resolver\n  /**\n   * Performs a [PATCH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH) request.\n   *\n   * ```js\n   * wretch(\"...\").json({...}).patch()\n   * ```\n   *\n   * @category HTTP\n   */\n  patch(this: Self & Wretch<Self, Chain, Resolver>, body?: any, url?: string):\n    Resolver extends undefined ?\n    Chain & WretchResponseChain<Self, Chain, Resolver> :\n    Resolver\n  /**\n   * Performs a [HEAD](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD) request.\n   *\n   * ```js\n   * wretch(\"...\").head();\n   * ```\n   *\n   * @category HTTP\n   */\n  head(this: Self & Wretch<Self, Chain, Resolver>, url?: string):\n    Resolver extends undefined ?\n    Chain & WretchResponseChain<Self, Chain, Resolver> :\n    Resolver\n  /**\n   * Performs an [OPTIONS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS) request.\n   *\n   * ```js\n   * wretch(\"...\").opts();\n   * ```\n   *\n   * @category HTTP\n   */\n  opts(this: Self & Wretch<Self, Chain, Resolver>, url?: string):\n    Resolver extends undefined ?\n    Chain & WretchResponseChain<Self, Chain, Resolver> :\n    Resolver\n}\n\n/**\n * The resolver interface to chaining catchers and extra methods after the request has been sent.\n * Ultimately returns a Promise.\n *\n */\nexport interface WretchResponseChain<T, Self = unknown, R = undefined> {\n  /**\n   * @private @internal\n   */\n  _wretchReq: Wretch<T, Self, R>,\n  /**\n   * @private @internal\n   */\n  _fetchReq: Promise<WretchResponse>,\n  /**\n   * @private @internal\n   */\n  _sharedState: Record<any, any>,\n\n  /**\n   *\n   * The handler for the raw fetch Response.\n   * Check the [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Response) documentation for more details on the Response class.\n   *\n   * ```js\n   * wretch(\"...\").get().res((response) => console.log(response.url));\n   * ```\n   *\n   * @category Response Type\n   */\n  res: <Result = WretchResponse>(cb?: (type: WretchResponse) => Promise<Result> | Result) => Promise<Awaited<Result>>,\n  /**\n   * Read the payload and deserialize it as JSON.\n   *\n   * ```js\n   * wretch(\"...\").get().json((json) => console.log(Object.keys(json)));\n   * ```\n   *\n   * @category Response Type\n   */\n  json: <Result = unknown>(cb?: (type: any) => Promise<Result> | Result) => Promise<Awaited<Result>>,\n  /**\n   * Read the payload and deserialize it as a Blob.\n   *\n   * ```js\n   * wretch(\"...\").get().blob(blob => …)\n   * ```\n   *\n   * @category Response Type\n   */\n  blob: <Result = Blob>(cb?: (type: Blob) => Promise<Result> | Result) => Promise<Awaited<Result>>,\n  /**\n   * Read the payload and deserialize it as a FormData object.\n   *\n   * ```js\n   * wretch(\"...\").get().formData(formData => …)\n   * ```\n   *\n   * @category Response Type\n   */\n  formData: <Result = FormData>(cb?: (type: FormData) => Promise<Result> | Result) => Promise<Awaited<Result>>,\n  /**\n   * Read the payload and deserialize it as an ArrayBuffer object.\n   *\n   * ```js\n   * wretch(\"...\").get().arrayBuffer(arrayBuffer => …)\n   * ```\n   *\n   * @category Response Type\n   */\n  arrayBuffer: <Result = ArrayBuffer>(cb?: (type: ArrayBuffer) => Promise<Result> | Result) => Promise<Awaited<Result>>,\n  /**\n   * Retrieves the payload as a string.\n   *\n   * ```js\n   * wretch(\"...\").get().text((txt) => console.log(txt));\n   * ```\n   *\n   * @category Response Type\n   */\n  text: <Result = string>(cb?: (type: string) => Promise<Result> | Result) => Promise<Awaited<Result>>,\n\n  /**\n   * Catches an http response with a specific error code or name and performs a callback.\n   *\n   * The original request is passed along the error and can be used in order to\n   * perform an additional request.\n   *\n   * ```js\n   * wretch(\"/resource\")\n   *   .get()\n   *   .unauthorized(async (error, req) => {\n   *     // Renew credentials\n   *     const token = await wretch(\"/renewtoken\").get().text();\n   *     storeToken(token);\n   *     // Replay the original request with new credentials\n   *     return req.auth(token).get().unauthorized((err) => {\n   *       throw err;\n   *     }).json();\n   *   })\n   *   .json()\n   *   // The promise chain is preserved as expected\n   *   // \".then\" will be performed on the result of the original request\n   *   // or the replayed one (if a 401 error was thrown)\n   *   .then(callback);\n   * ```\n   *\n   * @category Catchers\n   */\n  error: (this: Self & WretchResponseChain<T, Self, R>, code: (number | string | symbol), cb: WretchErrorCallback<T, Self, R>) => this,\n  /**\n   * Catches a bad request (http code 400) and performs a callback.\n   *\n   * _Syntactic sugar for `error(400, cb)`._\n   *\n   * @see {@link WretchResponseChain.error}\n   * @category Catchers\n   */\n  badRequest: (this: Self & WretchResponseChain<T, Self, R>, cb: WretchErrorCallback<T, Self, R>) => this,\n  /**\n   * Catches an unauthorized request (http code 401) and performs a callback.\n   *\n   * _Syntactic sugar for `error(401, cb)`._\n   *\n   * @see {@link WretchResponseChain.error}\n   * @category Catchers\n   */\n  unauthorized: (this: Self & WretchResponseChain<T, Self, R>, cb: WretchErrorCallback<T, Self, R>) => this,\n  /**\n   * Catches a forbidden request (http code 403) and performs a callback.\n   *\n   * _Syntactic sugar for `error(403, cb)`._\n   *\n   * @see {@link WretchResponseChain.error}\n   * @category Catchers\n   */\n  forbidden: (this: Self & WretchResponseChain<T, Self, R>, cb: WretchErrorCallback<T, Self, R>) => this,\n  /**\n   * Catches a \"not found\" request (http code 404) and performs a callback.\n   *\n   * _Syntactic sugar for `error(404, cb)`._\n   *\n   * @see {@link WretchResponseChain.error}\n   * @category Catchers\n   */\n  notFound: (this: Self & WretchResponseChain<T, Self, R>, cb: WretchErrorCallback<T, Self, R>) => this,\n  /**\n   * Catches a timeout (http code 408) and performs a callback.\n   *\n   *\n   * _Syntactic sugar for `error(408, cb)`._\n   *\n   * @see {@link WretchResponseChain.error}\n   * @category Catchers\n   */\n  timeout: (this: Self & WretchResponseChain<T, Self, R>, cb: WretchErrorCallback<T, Self, R>) => this,\n  /**\n   * Catches an internal server error (http code 500) and performs a callback.\n   *\n   *\n   * _Syntactic sugar for `error(500, cb)`._\n   *\n   * @see {@link WretchResponseChain.error}\n   * @category Catchers\n   */\n  internalError: (this: Self & WretchResponseChain<T, Self, R>, cb: WretchErrorCallback<T, Self, R>) => this,\n  /**\n   * Catches any error thrown by the fetch function and perform the callback.\n   *\n   * @see {@link WretchResponseChain.error}\n   * @category Catchers\n   */\n  fetchError: (this: Self & WretchResponseChain<T, Self, R>, cb: WretchErrorCallback<T, Self, R>) => this,\n}\n\n/**\n * Configuration object.\n */\nexport type Config = {\n  options: {};\n  errorType: string;\n  polyfills: {};\n  polyfill(p: string, doThrow?: boolean, instance?: boolean, ...args: any[]): any;\n}\n\n/**\n * Fetch Request options with additional properties.\n */\nexport type WretchOptions = Record<string, any>\n/**\n * An Error enhanced with status, text and body.\n */\nexport interface WretchError extends Error { status: number, response: WretchResponse, url: string, text?: string, json?: any }\n/**\n * Callback provided to catchers on error. Contains the original wretch instance used to perform the request.\n */\nexport type WretchErrorCallback<T, C, R> = (error: WretchError, originalRequest: Wretch<T, C, R>) => any\n/**\n * Fetch Response object with additional properties.\n */\nexport type WretchResponse = Response & { [key: string]: any }\n/**\n * Callback provided to the defer function allowing to chain deferred actions that will be stored and applied just before the request is sent.\n */\nexport type WretchDeferredCallback<T, C, R> = (wretch: T & Wretch<T, C, R>, url: string, options: WretchOptions) => Wretch<T, C, any>\n\n/**\n * Shape of a typical middleware.\n * Expects options and returns a ConfiguredMiddleware that can then be registered using the .middlewares function.\n */\nexport type Middleware = (options?: { [key: string]: any }) => ConfiguredMiddleware\n/**\n * A ready to use middleware which is called before the request is sent.\n * Input is the next middleware in the chain, then url and options.\n * Output is a promise.\n */\nexport type ConfiguredMiddleware = (next: FetchLike) => FetchLike\n/**\n * Any function having the same shape as fetch().\n */\nexport type FetchLike = (url: string, opts: WretchOptions) => Promise<WretchResponse>\n\n/**\n * An addon enhancing either the request or response chain (or both).\n */\nexport type WretchAddon<W extends unknown, R extends unknown = unknown> = {\n  beforeRequest?<T, C, R>(wretch: T & Wretch<T, C, R>, options: WretchOptions, state: Record<any, any>): T & Wretch<T, C, R>,\n  wretch?: W,\n  resolver?: R\n}\n\n"]}