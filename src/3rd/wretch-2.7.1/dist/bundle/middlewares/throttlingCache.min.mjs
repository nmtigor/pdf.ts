const e=(e,t)=>t.skipCache||"GET"!==t.method,t=(e,t)=>t.method+"@"+e,n=(e,t)=>0,o=(e,t)=>null,c=e=>e.ok,r=({throttle:r=1e3,skip:a=e,key:s=t,clear:h=n,invalidate:i=o,condition:l=c,flagResponseOnCacheHit:f="__cached"}={})=>{const d=new Map,p=new Map,u=new Set,g=e=>{r&&!u.has(e)&&(u.add(e),setTimeout((()=>{u.delete(e)}),r))},m=e=>(t,n)=>{const o=s(t,n);let c=i(t,n);if(c&&(c instanceof Array||(c=[c]),c.forEach((e=>{"string"==typeof e?d.delete(e):e instanceof RegExp&&d.forEach(((t,n)=>{e.test(n)&&d.delete(n)}))}))),h(t,n)&&d.clear(),a(t,n))return e(t,n);if(u.has(o)){if(d.has(o)){const e=d.get(o).clone();return f&&Object.defineProperty(e,f,{value:o,enumerable:0}),Promise.resolve(e)}if(p.has(o))return new Promise(((e,t)=>{p.get(o).push([e,t])}))}return p.has(o)||p.set(o,[]),g(o),e(t,n).then((e=>(l(e.clone())&&d.set(o,e.clone()),p.get(o).forEach((([t])=>t(e.clone()))),p.delete(o),e))).catch((e=>{throw p.get(o).forEach((([t,n])=>n(e))),p.delete(o),e}))};return m.cacheResponse=function(e,t){g(e),d.set(e,t)},m.cache=d,m.inflight=p,m.throttling=u,m};export{r as throttlingCache};
//# sourceMappingURL=throttlingCache.min.mjs.map
