{"version":3,"file":"perfs.min.js","sources":["../../../src/addons/perfs.ts"],"sourcesContent":["import type { WretchResponseChain, WretchAddon } from \"../types.js\"\n\nexport interface PerfsAddon {\n  /**\n   * Performs a callback on the API performance timings of the request.\n   *\n   * Warning: Still experimental on browsers and node.js\n   */\n  perfs: <T, C extends PerfsAddon, R>(this: C & WretchResponseChain<T, C, R>, cb?: (timing: any) => void) => this,\n}\n\n/**\n * Adds the ability to measure requests using the Performance Timings API.\n *\n * Uses the Performance API\n * ([browsers](https://developer.mozilla.org/en-US/docs/Web/API/Performance_API) &\n * [node.js](https://nodejs.org/api/perf_hooks.html)) to expose timings related to\n * the underlying request.\n *\n * Browser timings are very accurate, node.js only contains raw measures.\n *\n * ```js\n * import PerfsAddon from \"wretch/addons/perfs\"\n *\n * // Use perfs() before the response types (text, json, ...)\n * wretch(\"...\")\n *   .addon(PerfsAddon())\n *   .get()\n *   .perfs((timings) => {\n *     // Will be called when the timings are ready.\n * console.log(timings.startTime);\n *   })\n *   .res();\n *\n * ```\n *\n * For node.js, there is a little extra work to do :\n *\n * ```js\n * // Node.js only\n * const { performance, PerformanceObserver } = require(\"perf_hooks\");\n *\n * wretch.polyfills({\n *   fetch: function (url, opts) {\n *     performance.mark(url + \" - begin\");\n *     return fetch(url, opts).then(res => {\n *       performance.mark(url + \" - end\");\n *       setTimeout(() => performance.measure(res.url, url + \" - begin\", url + \" - end\"), 0);\n *       return res;\n *     });\n *   },\n *   // other polyfillsâ€¦\n *   performance: performance,\n *   PerformanceObserver: PerformanceObserver,\n * });\n * ```\n */\nconst perfs: () => WretchAddon<unknown, PerfsAddon> = () => {\n  const callbacks = new Map()\n  let observer = null\n\n  const onMatch = (entries, name, callback, performance) => {\n    if (!entries.getEntriesByName)\n      return false\n    const matches = entries.getEntriesByName(name)\n    if (matches && matches.length > 0) {\n      callback(matches.reverse()[0])\n      if (performance.clearMeasures)\n        performance.clearMeasures(name)\n      callbacks.delete(name)\n\n      if (callbacks.size < 1) {\n        observer.disconnect()\n        if (performance.clearResourceTimings) {\n          performance.clearResourceTimings()\n        }\n      }\n      return true\n    }\n    return false\n  }\n\n  const initObserver = (performance, performanceObserver) => {\n    if (!observer && performance && performanceObserver) {\n      observer = new performanceObserver(entries => {\n        callbacks.forEach((callback, name) => {\n          onMatch(entries, name, callback, performance)\n        })\n      })\n      if (performance.clearResourceTimings) {\n        performance.clearResourceTimings()\n      }\n    }\n\n    return observer\n  }\n\n  const monitor = (name, callback, config) => {\n    if (!name || !callback)\n      return\n\n    const performance = config.polyfill(\"performance\", false)\n    const performanceObserver = config.polyfill(\"PerformanceObserver\", false)\n\n    if (!initObserver(performance, performanceObserver))\n      return\n\n    if (!onMatch(performance, name, callback, performance)) {\n      if (callbacks.size < 1)\n        observer.observe({ entryTypes: [\"resource\", \"measure\"] })\n      callbacks.set(name, callback)\n    }\n  }\n\n  return {\n    resolver: {\n      perfs(cb) {\n        this._fetchReq\n          .then(res =>\n            monitor(this._wretchReq._url, cb, this._wretchReq._config)\n          )\n          .catch(() => {/* swallow */ })\n        return this\n      },\n    }\n  }\n}\n\nexport default perfs\n"],"names":["callbacks","Map","observer","onMatch","entries","name","callback","performance","getEntriesByName","matches","length","reverse","clearMeasures","delete","size","disconnect","clearResourceTimings","resolver","perfs","cb","this","_fetchReq","then","res","config","polyfill","performanceObserver","forEach","initObserver","observe","entryTypes","set","monitor","_wretchReq","_url","_config","catch"],"mappings":"uPAyDsD,KACpD,MAAMA,EAAY,IAAIC,IACtB,IAAIC,EAAW,KAEf,MAAMC,EAAU,CAACC,EAASC,EAAMC,EAAUC,KACxC,IAAKH,EAAQI,iBACX,OAAO,EACT,MAAMC,EAAUL,EAAQI,iBAAiBH,GACzC,OAAII,GAAWA,EAAQC,OAAS,GAC9BJ,EAASG,EAAQE,UAAU,IACvBJ,EAAYK,eACdL,EAAYK,cAAcP,GAC5BL,EAAUa,OAAOR,GAEbL,EAAUc,KAAO,IACnBZ,EAASa,aACLR,EAAYS,sBACdT,EAAYS,wBAGT,GAEF,CAAK,EAmCd,MAAO,CACLC,SAAU,CACRC,MAAMC,GAMJ,OALAC,KAAKC,UACFC,MAAKC,GArBE,EAAClB,EAAMC,EAAUkB,KAC/B,IAAKnB,IAASC,EACZ,OAEF,MAAMC,EAAciB,EAAOC,SAAS,cAAe,GAnBhC,EAAClB,EAAamB,MAC5BxB,GAAYK,GAAemB,IAC9BxB,EAAW,IAAIwB,GAAoBtB,IACjCJ,EAAU2B,SAAQ,CAACrB,EAAUD,KAC3BF,EAAQC,EAASC,EAAMC,EAAUC,EAAY,GAC7C,IAEAA,EAAYS,sBACdT,EAAYS,wBAITd,GAUF0B,CAAarB,EAFUiB,EAAOC,SAAS,sBAAuB,MAK9DtB,EAAQI,EAAaF,EAAMC,EAAUC,KACpCP,EAAUc,KAAO,GACnBZ,EAAS2B,QAAQ,CAAEC,WAAY,CAAC,WAAY,aAC9C9B,EAAU+B,IAAI1B,EAAMC,IACrB,EAQO0B,CAAQZ,KAAKa,WAAWC,KAAMf,EAAIC,KAAKa,WAAWE,WAEnDC,OAAM,SACFhB,IACR,GAEJ"}