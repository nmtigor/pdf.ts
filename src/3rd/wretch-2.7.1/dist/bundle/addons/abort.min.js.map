{"version":3,"file":"abort.min.js","sources":["../../../src/addons/abort.ts"],"sourcesContent":["import type { Wretch, WretchAddon, WretchErrorCallback, WretchResponseChain } from \"../types.js\"\n\nexport interface AbortWretch {\n  /**\n   * Associates a custom controller with the request.\n   *\n   * Useful when you need to use\n   * your own AbortController, otherwise wretch will create a new controller itself.\n   *\n   * ```js\n   * const controller = new AbortController()\n   *\n   * // Associates the same controller with multiple requests\n   * wretch(\"url1\")\n   *   .addon(AbortAddon())\n   *   .signal(controller)\n   *   .get()\n   *   .json()\n   * wretch(\"url2\")\n   *   .addon(AbortAddon())\n   *   .signal(controller)\n   *   .get()\n   *   .json()\n   *\n   * // Aborts both requests\n   * controller.abort()\n   * ```\n   *\n   * @param controller - An instance of AbortController\n   */\n  signal: <T extends AbortWretch, C, R>(this: T & Wretch<T, C, R>, controller: AbortController) => this\n}\n\nexport interface AbortResolver {\n  /**\n   * Aborts the request after a fixed time.\n   *\n   * If you use a custom AbortController associated with the request, pass it as the second argument.\n   *\n   * ```js\n   * // 1 second timeout\n   * wretch(\"...\").addon(AbortAddon()).get().setTimeout(1000).json(_ =>\n   *   // will not be called if the request timeouts\n   * )\n   * ```\n   *\n   * @param time - Time in milliseconds\n   * @param controller - An instance of AbortController\n   */\n  setTimeout: <T, C extends AbortResolver, R>(this: C & WretchResponseChain<T, C, R>, time: number, controller?: AbortController) => this\n  /**\n   * Returns the provided or generated AbortController plus the wretch response chain as a pair.\n   *\n   * ```js\n   * // We need the controller outside the chain\n   * const [c, w] = wretch(\"url\")\n   *   .addon(AbortAddon())\n   *   .get()\n   *   .controller()\n   *\n   * // Resume with the chain\n   * w.onAbort(_ => console.log(\"ouch\")).json()\n   *\n   * // Later onâ€¦\n   * c.abort()\n   * ```\n   */\n  controller: <T, C extends AbortResolver, R>(this: C & WretchResponseChain<T, C, R>) => [any, this]\n  /**\n   * Catches an AbortError and performs a callback.\n   */\n  onAbort: <T, C extends AbortResolver, R>(this: C & WretchResponseChain<T, C, R>, cb: WretchErrorCallback<T, C, R>) => this\n}\n\n/**\n * Adds the ability to abort requests using AbortController and signals under the hood.\n *\n *\n * _Only compatible with browsers that support\n * [AbortControllers](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).\n * Otherwise, you could use a (partial)\n * [polyfill](https://www.npmjs.com/package/abortcontroller-polyfill)._\n *\n * ```js\n * import AbortAddon from \"wretch/addons/abort\"\n *\n * const [c, w] = wretch(\"...\")\n *   .addon(AbortAddon())\n *   .get()\n *   .onAbort((_) => console.log(\"Aborted !\"))\n *   .controller();\n *\n * w.text((_) => console.log(\"should never be called\"));\n * c.abort();\n *\n * // Or :\n *\n * const controller = new AbortController();\n *\n * wretch(\"...\")\n *   .addon(AbortAddon())\n *   .signal(controller)\n *   .get()\n *   .onAbort((_) => console.log(\"Aborted !\"))\n *   .text((_) => console.log(\"should never be called\"));\n *\n * controller.abort();\n * ```\n */\nconst abort: () => WretchAddon<AbortWretch, AbortResolver> = () => {\n  return {\n    beforeRequest(wretch, options, state) {\n      const fetchController = wretch._config.polyfill(\"AbortController\", false, true)\n      if (!options[\"signal\"] && fetchController) {\n        options[\"signal\"] = fetchController.signal\n      }\n      const timeout = {\n        ref: null,\n        clear() {\n          if (timeout.ref) {\n            clearTimeout(timeout.ref)\n            timeout.ref = null\n          }\n        }\n      }\n      state.abort = {\n        timeout,\n        fetchController\n      }\n      return wretch\n    },\n    wretch: {\n      signal(controller) {\n        return { ...this, _options: { ...this._options, signal: controller.signal } }\n      },\n    },\n    resolver: {\n      setTimeout(time, controller = this._sharedState.abort.fetchController) {\n        const { timeout } = this._sharedState.abort\n        timeout.clear()\n        timeout.ref = setTimeout(() => controller.abort(), time)\n        return this\n      },\n      controller() { return [this._sharedState.abort.fetchController, this] },\n      onAbort(cb) { return this.error(\"AbortError\", cb) }\n    },\n  }\n}\n\nexport default abort\n"],"names":["beforeRequest","wretch","options","state","fetchController","_config","polyfill","signal","timeout","ref","clear","clearTimeout","abort","controller","this","_options","resolver","setTimeout","time","_sharedState","onAbort","cb","error"],"mappings":"uPA6G6D,KACpD,CACLA,cAAcC,EAAQC,EAASC,GAC7B,MAAMC,EAAkBH,EAAOI,QAAQC,SAAS,kBAAmB,EAAO,IACrEJ,EAAgB,QAAKE,IACxBF,EAAgB,OAAIE,EAAgBG,QAEtC,MAAMC,EAAU,CACdC,IAAK,KACLC,QACMF,EAAQC,MACVE,aAAaH,EAAQC,KACrBD,EAAQC,IAAM,KAEjB,GAMH,OAJAN,EAAMS,MAAQ,CACZJ,UACAJ,mBAEKH,CACR,EACDA,OAAQ,CACNM,OAAOM,GACL,MAAO,IAAKC,KAAMC,SAAU,IAAKD,KAAKC,SAAUR,OAAQM,EAAWN,QACpE,GAEHS,SAAU,CACRC,WAAWC,EAAML,EAAaC,KAAKK,aAAaP,MAAMR,iBACpD,MAAMI,QAAEA,GAAYM,KAAKK,aAAaP,MAGtC,OAFAJ,EAAQE,QACRF,EAAQC,IAAMQ,YAAW,IAAMJ,EAAWD,SAASM,GAC5CJ,IACR,EACDD,aAAe,MAAO,CAACC,KAAKK,aAAaP,MAAMR,gBAAiBU,KAAO,EACvEM,QAAQC,GAAM,OAAOP,KAAKQ,MAAM,aAAcD,EAAK"}